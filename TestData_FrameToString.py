# StackFrameToString

tests = [
    # signaturification
    {
        "desc": "signaturification remove args 1",
        "expected": "function_name",
        "function": "function_name()",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove args 2",
        "expected": "function_name",
        "function": "function_name(())",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove args 3",
        "expected": "function_name",
        "function": "function_name(()",
        "forSignaturification": True,
    },
    {
        "desc": "empty function name",
        "expected": "<???>",
        "function": "",
        "forSignaturification": True,
    },

    # remove anonymous
    {
        "desc": "signaturification remove anonymous 1",
        "expected": "unnamed::function_name",
        "function": "`lambda at ()'::function_name(()",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove anonymous 2",
        "expected": "unnamed::function_name",
        "function": "template<T>  `anonymous namespace at ()'::function_name()",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove anonymous 3",
        "expected": "unnamed::function_name",
        "function": "template<T>  `anonymous namespace at ()'::function_name(`lambda at xyz'&&)",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove anonymous 4",
        "expected": "mozilla::detail::RunnableFunction<T>::Run",
        "function": "nsresult mozilla::detail::RunnableFunction<`lambda at z:\\/build\\/build\\/src\\/dom\\/html\\/HTMLMediaElement.cpp:7150:11'>::Run()",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove anonymous 5",
        "expected": "unnamed::LoadLibrarySystem32",
        "function": "struct HINSTANCE__* `anonymous namespace'::LoadLibrarySystem32(const wchar_t*)",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove anonymous 6",
        "expected": "IPC::ParamTraits<T>::Read",
        #"function": "bool IPC::ParamTraits<mozilla::COMPtrHolder<IAccessible, &IID_IAccessible> >::Read(const class IPC::Message*, class PickleIterator*, class mozilla::COMPtrHolder<IAccessible, &IID_IAccessible>*)",
        "function": "bool IPC::ParamTraits<mozilla::COMPtrHolder<IAccessible, &IID_IAccessible> >::Read(const class IPC::Message*, class PickleIterator*, class mozilla::COMPtrHolder<IAccessible, &IID_IAccessible>*)",
        "forSignaturification": True,
    },

    {
        "desc": "signaturification remove fn args 1",
        "expected": "fn",
        #"debug": True,
        "function": "void fn(1, 3)",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove fn args 2",
        "expected": "fn",
        "function": "void fn(void(*)(int), 3)",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove fn args 2",
        "expected": "fn",
        #"debug": True,
        "function": "void (*fn(char))(int)",#"void(*fn(void))((*)(int), 3)",
        "forSignaturification": True,
    },
    {
        "desc": "signaturification remove fn args 3",
        "expected": "fn",
        #"debug": True,
        "function": "void(*fn(void))((*)(int), 3)",
        "forSignaturification": True,
    },

    {
        "desc": "StackFrameToString case 1",
        "expected": "module!function_name()+0x20",
        "frame": 0,
        "module": "module",
        "module_offset": "0x20",
        "function": "function_name()",
        "function_offset": "0x20",
        "forSignaturification": False,
    },
    {
        "desc": "StackFrameToString case 2",
        "expected": "module!function_name()",
        "frame": 0,
        "module": "module",
        "module_offset": "0x20",
        "function": "function_name()",
        "forSignaturification": False,
    },
    {
        "desc": "StackFrameToString case 3",
        "expected": "module+0x20",
        "frame": 0,
        "module": "module",
        "module_offset": "0x20",
    },
    {
        "desc": "StackFrameToString case 4",
        "expected": "module",
        "frame": 0,
        "module": "module",
    },
    {
        "desc": "StackFrameToString case 5",
        "expected": "function_name()+0x20",
        "frame": 0,
        "module_offset": "0x20",
        "function": "function_name()",
        "function_offset": "0x20",
    },
    {
        "desc": "StackFrameToString case 6",
        "expected": "function_name()",
        "frame": 0,
        "function": "function_name()",
    },
    {
        "desc": "StackFrameToString case 7",
        "expected": "@0x20",
        "frame": 0,
        "module_offset": "0x20",
    },
    {
        "desc": "StackFrameToString case 8",
        "expected": "<???>",
        "frame": 0,
    },
    {
        "desc": ".pdb is removed from module name",
        "expected": "module.dll",
        "frame": 0,
        "module": "module.dll.pdb",
    },

    # FUNCTION NAME TESTS
    {
        "desc": "Remove args 1",
        "forSignaturification": True,
        "expected": "mod!function_name+0x20",
        "frame": 0,
        "module": "mod",
        "function": "function_name()",
        "function_offset": "0x20",
    },
    {
        "desc": "Remove args 2",
        "forSignaturification": True,
        "expected": "function_name",
        "frame": 0,
        "function": "function_name(",
    },
    {
        "desc": "Remove args 3",
        "forSignaturification": True,
        "expected": "function_name",
        "frame": 0,
        "function": "function_name(())",
    },
    {
        "desc": "Remove args 4: realistic args",
        "forSignaturification": True,
        "expected": "function_name",
        "frame": 0,
        "function": "function_name(int x, int (*)(int,bool))",
    },
    {
        "desc": "Remove leading qualifiers 1: remove void",
        "forSignaturification": True,
        "expected": "function_name",
        "frame": 0,
        "function": "void function_name",
    },
    {
        "desc": "Remove leading qualifiers 2: don't remove",
        "forSignaturification": True,
        "expected": "function_name",
        "frame": 0,
        "function": "bool function_name",
    },
    {
        "desc": "Remove leading qualifiers 3: remove static void, check multi spaces",
        "forSignaturification": True,
        "expected": "function_name",
        "frame": 0,
        "function": "static  const    void  function_name",
    },
    {
        "desc": "Remove leading qualifiers 4: don't remove if part of fn",
        "expected": "voidfunction",
        "frame": 0,
        "function": "static voidfunction",
    },
    {
        "desc": "Remove leading qualifiers 5: only remove if leading",
        "expected": "function(static void) static",
        "frame": 0,
        "function": "static function(static void) static",
    },

    {
        "desc": "Shorten unsigned types 1",
        "expected": "ulong unsignedfunction",
        "frame": 0,
        "function": "unsigned   long unsignedfunction",
    },
    {
        "desc": "Shorten unsigned types 2: basic",
        "expected": "fn(uint8, uint, ushort)",
        "frame": 0,
        "function": "fn(unsigned  __int8, unsigned int, unsigned short)",
    },
    {
        "desc": "Shorten unsigned types 3: basic, continued",
        "expected": "uint16 fn(uchar, uint64, uint16)",
        "frame": 0,
        "function": "unsigned __int16 fn(unsigned char, unsigned __int64, unsigned __int16)",
    },
    {
        "desc": "Tighten spaces before asterisks",
        "expected": "**fn(char*const*x)",
        "frame": 0,
        "function": "void  *  *fn(char  *const  *x)",
    },
    {
        "desc": "Normalize spaces after commas",
        "expected": "fn(a, b, c, d)",
        "frame": 0,
        "function": "fn(a,b, c,  d)",
    },
    {
        "desc": "Operator and template args, tighten spaces",
        "expected": "X<Y<Z>> operator << (t<1> a, t<u<2, 3>, 4> b)",
        "frame": 0,
        "function": "X<Y<Z>> operator  <<  (t<1>  a,  t<u<2,3>,4>  b)",
    },

    # vexing frame signatures
    {
        "desc": "framesig: Normal function",
        "forSignaturification": True,
        "expected": "fn",
        "frame": 0,
        "function": "const void fn (const int *n) const",
    },
    {
        "desc": "framesig: return array",
        "forSignaturification": True,
        "expected": "fn",
        "frame": 0,
        "function": "const int fn (const int *n)[] const",
    },
    {
        "desc": "framesig: remove template args",
        "forSignaturification": True,
        "expected": "fn",
        "frame": 0,
        "function": "const INT<MyType <void (*)(int, char)>, bool> fn (const int *n)[] const",
    },
    {
        "desc": "framesig: return array of function ptrs",
        "forSignaturification": True,
        "expected": "fn",
        "frame": 0,
        "function": "int (*fn(const int *n)[])(double, int) const",
    },


    {
        "desc": "framesig: operator>>",
        "forSignaturification": True,
        "expected": "c::operator >>",
        "frame": 0,
        "function": "a::b<X> c::operator>> (d::x<X>&&)",
    },
    {
        "desc": "framesig: operator *",
        "forSignaturification": True,
        "expected": "c::operator *",
        "frame": 0,
        "function": "c::operator  *",
    },
    {
        "desc": "framesig: operator ->*",
        "forSignaturification": True,
        "expected": "c::operator ->*",
        "frame": 0,
        "function": "c::operator ->* ()",
    },
    {
        "desc": "framesig: operator ()",
        "forSignaturification": True,
        "expected": "c::operator ()",
        "frame": 0,
        "function": "c::operator()",
    },
    {
        "desc": "framesig: operator ()",
        "forSignaturification": True,
        "expected": "operator ()",
        "frame": 0,
        "function": "operator()()",
    },
    {
        "desc": "framesig: operator () with spaces. since we don't attempt to parse the operator text, keeps the spaces",
        "forSignaturification": True,
        "expected": "operator (  )",
        "frame": 0,
        "function": "operator(  )()",
    },
    {
        "desc": "framesig: operator +",
        "forSignaturification": True,
        "expected": "operator +",
        "frame": 0,
        "function": "operator+()",
    },
    {
        "desc": "framesig: operator + no args",
        "forSignaturification": True,
        "expected": "operator +",
        "frame": 0,
        "function": "operator+",
    },
    {
        "desc": "framesig: operator ++",
        "forSignaturification": True,
        "expected": "operator ++",
        "frame": 0,
        "function": "operator++()",
    },
    {
        "desc": "framesig: non-vexing operators are preserved",
        "forSignaturification": True,
        "expected": "operator +++",
        "frame": 0,
        "function": "operator+++()",
    },
    {
        "desc": "framesig: operator ***. Nonsense but test that the algo doesn't blow up.",
        "forSignaturification": True,
        "expected": "operator ***",
        "frame": 0,
        "function": "operator***()",
    },
    {
        "desc": "framesig: operator type",
        "forSignaturification": True,
        "expected": "operator const int",
        "frame": 0,
        "function": "operator   const int()",
    },
    {
        "desc": "framesig: conversion operator to templated type",
        "forSignaturification": True,
        "expected": "my<T>::X::operator const std::vector<T<X>, A>",
        "frame": 0,
        "function": "my<TYPE>::X::operator const std::vector<T<X>, A>",
    },
    {
        "desc": "framesig: operator new[]",
        "forSignaturification": True,
        "expected": "xyz::operator new[]",
        "frame": 0,
        "function": "const char *xyz::operator new[](size_t n)",
    },
    {
        "desc": "framesig: trailing qualifiers",
        "expected": "xyz::abc()",
        "frame": 0,
        "function": "void xyz::abc()   const&&",
    },
    {
        "desc": "framesig: leading and trailing qualifier",
        "expected": "xyz::abc()",
        "frame": 0,
        "function": "static void xyz::abc() const",
    },
    # {
    #     # this is basically the most vexing and would require proper C++ type
    #     # parsing. so it's going to be unparsable.
    #     "desc": "framesig: conversion operator to function type",
    #     "forSignaturification": True,
    #     "expected": "my<T>::X::operator const std::function<void",
    #     "frame": 0,
    #     "function": "my<TYPE>::X::operator const std::function<void()>",
    # },
    # {
    #     # Also just too vexing.
    #     "desc": "framesig: function pointer indirect return type",
    #     "forSignaturification": True,
    #     "expected": "fn",
    #     "frame": 0,
    #     "function": "std::function<void(int(*)(int))> fn()",
    # },
    # {
    #     # Also just too vexing.
    #     "desc": "framesig: redundant parens cause problems",
    #     "forSignaturification": True,
    #     "expected": "fn",
    #     "frame": 0,
    #     "function": "void (((*fn(char))))(int)",
    # },
]
